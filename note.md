### 写时复制技术 Copy-On-Write
在多线程环境中，多个线程之间常常共享数据结构，当多个线程同时读取和修改这个表，如果不加以同步，就会导致竞争，迭代器失效，死锁
虽然可以使用互斥锁来保护列表，但每次访问都需要加锁，影响性能，并有死锁的风险，于是就有了写时复制技术
这种方式可以避免在读取时加锁，提高性能，同时，写入操作不会影响正在进行的读取操作，避免了迭代器的失效和数据竞争
关键思想
>在读取时使用原始数据，不加锁，写入是时复制一份副本，在副本上修改，然后**原子的**替换数据指针

    //示例
    std::mutex mutex_;
    std::shared_ptr<std::vector<Foo*>> foos_ = std::make_shared<std::vector<Foo*>>();

    void post(Foo* foo) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto newFoos = std::make_shared<std::vector<Foo*>>(*foos_);
        newFoos->push_back(foo);
        foos_ = newFoos;
    }

    void doit() {
        std::shared_ptr<std::vector<Foo*>> foosCopy;
        {
            std::lock_guard<std::mutex> lock(mutex_);
            foosCopy = foos_;
        }
        for (auto& foo : *foosCopy) {
            foo->doit();
        }
    }

在当下，许多函数早已是线程安全的，关键在于不同的线程安全的函数组合到一起就会引发竟态，这是编写多线程程序的主要难点

### 多线程异步日志
使用一个背景线程来收集各个业务线程的日志，放到一个缓冲区里，总共准备两个缓冲区，设定一个时间将缓冲区里的内容写入日志文件，或是缓冲区满时使用条件变量通知，然后立刻将缓冲区文件写入，另一个缓冲区则用于写入日志时交换缓冲区

### 三个半事件
在书中，作者认为一个TCP连接通常需要处理一下三类主要事件以及一个次要事件
+ 建立连接事件，包括服务器接收新连接和客户端成功发起连接
+ 连接的断开，包括主动断开和被动断开
+ 消息到达，文件描述符可读

+ 消息发送完毕

### 处理粘包问题
TCP由于是字节流协议，会发生粘包问题，对于长连接的TCP服务，分包有四种方法
1. 消息长度固定，比如16字节，64字节
2. 使用特殊的字符或字符串作为分界，如HTTP协议中的"\r\n"作为分隔符
3. 在每条消息前加上字段长度，确保接收完整
4. 利用消息本身的格式来分包，例如XML格式的消息中<root>...</root>的配对，或者JSON格式中的{ ... }的配对。解析这种消息格式通常会用到状态机（state machine）

### non-blocking网络编程中应用层buffer是必需的
应用层buffer是在从内核读取到数据后将其放在程序中创建的一个缓冲区，程序处理数据直接从缓冲区来读取数据并处理，对于接受方和发送方都可以有
+ 接收方 从socket读出来的数据会暂存在这个buffer中
+ 发送方 发送的数据先进入buffer,在等待网络可写时在写入socket

为什么在非阻塞中是必须的
在非阻塞IO中socket调用read()或write()不能保证一次读取或写完整的数据，所以必须要用buffer来处理还没处理完的数据，总结原因有下
+ 接收数据不完整
+ 发送数据写不完
+ 非阻塞不会等待