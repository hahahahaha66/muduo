经过大概一个月的时间，复刻了muduo网络库的大部分内容，其中主要分为base,logging和net三个部分
接下来我会尽可能的讲述每个类的作用及细节，算是对一个月的复盘

### base
base库是作为整个网络库的基石，他所完成的类都会作为基础类进行使用，其中有CurrentThread,提供对当前所在线程的查询；Thread，对thread进行封装，使其生命周期更安全，更方便使用；noncopyable，对muduo中大部分的类实现不可拷贝和赋值操作符；Timestamp,时间戳类，调用获取当前的时间戳，返回格式化的时间格式

#### CurrentThread
使用打包好的系统调用syscall(SYS_gettid)，获取当前线程id,并进行缓存，并且总体上使用了命名空间，方便调用，总之该文件的作用就是提供一个高效获取当前线程id的方法

#### Thread
在用线程执行任务时，会使用该类，该类将thread的相关操作封装到类中，使其更安全，更易于操作，在创建线程时，使用信号量来实现主线程和子线程之间的同步

#### Timestamp
获取当前时间的秒数和微秒数，经过格式化输出，获取当前时间

---

### logging
该部分作为日志系统，这里未使用Buffer,只使用了一个简化版的FixBuffer,也使得可以将这部分文件移到任何其他项目中，作为日志系统。整体的结构还是十分巧妙的，整个系统大致可分为两个部分，一个是直接输出到终端的日志流，一个写入文件的异步日志

#### Logging
该部分实现了不同日志等级的日志流，默认输出到终端，也可以通过内置的函数来改变输出位置，该部分主要由两部分组成，一个是存储具体日志的LogStream,该文件通过重载<<运算符，使得日志得以以流式写入，方便了日志的书写；另一个是Logging，他是日志的整体，负责日志的格式，输出，并在此定义了多个日志等级，便于查看日志，在其中包裹了一个内部类Impl作为日志的具体实现，并使用宏隐藏了Logger的构造细节，使其使用更简单快捷

#### AsyncLogger
异步日志就有关于文件的操作，先从底层开始介绍，FileUtil完成了对底层文件的write的封装，实现了文件的创建，内容的追加，之后的类会封装这些函数供最终的类使用;在LogFile中，进一步实现文件的自动创建，包括文件的名字的内容，当前文件写满后创建新的文件，在这个类中对FileUtil的append,flush等进行封装，加入了锁，使其在多线程的环境下安全的写入到磁盘中，在就到了AsyncLogging,该类对缓冲区的使用极为巧妙，首先分为前端和后端线程，前后端共用一个存储写满Buffer数组的buffer_，前端独有CurrentBuffer和NextBuffer，有数据就写入CurrentBuffer,写满了就存到buffer_，交换NextBuffer,继续写入，如果都满了(很少出现)，就重新分配CurrentBuffer，以上是前端快写；后端慢写是启动另一线程，前后端线程通过条件变量同步通信，当前端有一个缓冲区写满，就会通知后端线程，后端线程提前创建好两个Buffer和一个vector<Buffer>的writeBuffer,writeBuffer读取buffer_中的写满的缓冲区，并限制writeBuffer数量不多于两个，开始向磁盘写入，同时使用先前创建好的Buffer替代前端线程写满的Buffer,待writeBuffer写完后，从中回收两个Buffer，作为一开始创建的两个备用Buffer，整体减少了频繁的创建Buffer,最大程度实现了Buffer的复用，并且提高了效率
>这里在说一下为什么要使用异步日志，正常的日志写入文件是有一条日志就写入磁盘，而日志的内容少，写入的次数多，频繁的写入造成极大的效率损耗，异步日志就是将要写入磁盘的内容放到缓冲区，再在后台一次性全部写入,而这就大大提升了效率

---

### net
核心的网络区，该部分主要分为Reactor模块，poller模块和tcp模块，接下来逐个介绍

#### Reactor
该部分是整个事件处理的核心，分为Channel，EventLoop和EventLooppool三个部分

#### Channel
一个Channel绑定一个文件描述符，他的核心参数有events_,以及各种事件的回调函数
